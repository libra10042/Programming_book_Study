# 스프링 핵심 기술의 응용

## SQL 과 DAO 의 분리 

> 1) XML 설정을 이용한 분리 
> - 개별 SQL프로퍼티 방식
> - SQL 맵 프로퍼티 방식. 
> 2) 리팩토링 <br>
> - SQL 제공서비스를 이용하는 방식. 
> - 스프링 설정을 사용하는 단순 SQL 

##### 개별 SQL 프로퍼티 방식. 

```JAVA
public class UserDaoJdbc implements UserDao {
    private String sqlAdd; 
    
    public void setSqlAdd(String sqlAdd){
        this.sqlAdd = sqlAdd;
    }
      
```

```JAVA
public void add(User user) {
    this.jdbcTemplate.update(
        this.sqlAdd, 
        user.getId(), user.getName(), user.getPassword(), user.getEmail(),
        user.getLevel().intValue(), user.getLogin(), user.getRecommand());
}
```

```JAVA
<bean id="userDao" class="springboot.user.dao.UserDaoJdbc">
    <property name="dataSource" ref="dataSource" />
    <property name="sqlAdd" value="insert into users(id, name, password, 
        email, level, login, recommand)  values(?,?,?,?,?,?,?)" />
```

##### SQL 맵 프로퍼티 방식. 

: UserDao에서 SQL을 주입받기 위해 개별적으로 정의한 프로퍼티를 모두 제거하자. <br>그리고 Map 타입의 sqlMap을 대신 추가한다.

```java
public class UserDaoJdbc implements UserDao{

    private Map<String, String> sqlMap;
    
    public void setSqlMap(Map<String, String> sqlMap){
        this.sqlMap = sqlMap;
    }
}
```

```java
public void add(User user){
    this.jdbcTemplate.update(
        this.sqlMap.get("add"),
        user.getId(), user.getName(), user.getPassword(), user.getEmail(), 
        user.getLevel().intValue(), user.getLogin(), user.getRecommand());
    )
```

```java
<bean id="uerDao" class="springbook.user.dao.UserDaoJdbc">
    <property name="dataSource" ref="dataSource" />
    <property name="sqlMap">
         <map>    
              <entry key="add" value="insert into users(id, name, password, email, level, login, recommend)
                                      valuse(?,?,?,?,?,?,?)" />
              <entry key="get" value="select * from users where id=?" />
              <entry key="getAll" value="select * from users order by id" />
              <entry key="deleteAll" value="delete from users" />
              <entry key="getCount" value="select count(*) from users" />
              <entry key="update" value="update users set name = ?, password = ?, email = ?, level =?, 
                                          login = ?, recommand = ? where id = ?" />
         </map>
    </property>
</bean>
```

" sql 맵 프로퍼티 방식은 해당 메소드가 실행되기 전에는 오류를 확인하기 힘들다는 단점이 있다. "

<br>

### SQL 제공 서비스를 이용한 방식. 

##### SqlService 인터페이스

```java
public interface SqlService{
     String getSql(String key) throws SqlRetrievalFailureException;

}
```

* SqlRetrievalFailureException : 이 예외는 복구가 불가능하므로 런타임 예외로 정의해 둔다.

##### SQL 조회 실패 시 예외

```java
public class SqlRetrievalFailureException extends RuntimeException {
     public SqlRetrievalFailureException(String message){
        super(message);
     }
     
     public SqlRetrievalFailureException(String message, Throwable cause){
        super(message, cause);
     }
}
```

##### SqlService 프로퍼티 추가. 

```java
public class UserDaoJdbc implements UserDao{
    private SqlService sqlService; 
    
    public void setSqlService(SqlService sqlService){
        this.sqlService = sqlService; 
    }
}
```

##### sqlService 를 사용하도록 수정한 메소드

```java
public void add(User user){
    this.jdbcTemplate.update(this.sqlService.getSql("userAdd"),
          user.getId(), user.getName(), user.getPassword(), user.getEmail(), 
          user.getLevel().intValue(), user.getLogin(), user.getRecommand());
}
    
public User get(String id){
    return this.jdbcTemplate.queryForObject(this.sqlService.getSql("userGet"),
        new Object[] {id}, this.userMapper);
}
   
public List<User> getAll(){
    return this.jdbcTemplate.query(this.sqlService.getSql("userGetAll"),
          this.userMapper);
}

public int getCount(){
    return this.jdbcTemplate.queryForInt(this.sqlService.getSql("userGetCount"));
}

public void update(User user){
    this.jdbcTemplate.update(this.sqlService.getSql("userUpdate"),
        user.getName(), user.getPassword(), user.getEmail(), 
        user.getLevel().intValue(), user.getLogin(), user.getRecommand(), 
        user.getId()); 
}

```


##### 스프링 설정을 사용하는 단순 SQL 서비스

```java

public class SimpleService implements SqlService{
    private Map<String, String> sqlMap;
    
    public void setSqlMap<String, String> sqlMap){
        this.sqlMap = sqlMap; 
    }
    
    
    public String getSql(String key) throws SqlRetrievalFailureException {
        String sql = sqlMap.get(key);
        
        if(sql == null)
            throw new SqlRetrievalFailureException( key + "에 대한 SQL을 찾을 수 없습니다");
        else {
            return sql; 
    }
}
```

```java
<bean id="userDao" class="springbook.dao.userDaoJdbc">
    <property name="dataSource" ref="dataSource" />
    <property name="sqlService" ref="sqlService" />
</bean>

<bean id="sqlService" class="springbook.user.sqlservice.SimpleSqlService">
    <property name"sqlMap">
        <map>
            <entry key="userAdd" value="insert into user(id, name, password, email, level, login, recomned) values(?, ?, ?, ?, ?, ?, ?)" />
            <entry key="userGet" value="select * from users where id = ?" />
            <entry key="userGetAll" value="select * from users order by id" />
            <entry key="userDeleteAll" value="delete from users" />
            <entry key="userGetCount" value="select count(*) from users" />
            <entry key="userUpdate" value="update users set name = ?, password = ?, email = ?, level = ?, login = ?, recommand = ? where id = ?" />
        </map>
    </property>
</bean>
```


----

## 인터페이스 분리와 자기참조 빈. 

### XML 파일 매핑 

> - JAXB
> - SQL 맵을 위한 스키마 작성과 컴파일 
> - 언마샬링

#### JAXB

 : XML에 담긴 정보를 파일에서 읽어오는 방법은 여러가지 인데 그중 하나가 JAXB (Java Architecture for XML Binding)를 이용했다. 
 
 * "DOM" 과 같은 전통적인 XML API 와 비교했을 때 JAXB의 장점은 XML 문서정보를 거의 동일한 구조의 오브젝트로 직접 매핑해준다는 것이다. 
 * "DOM"은 XML 정보를 마치 자바의 리플렉션 API를 사용해서 오브젝트를 조작하는 것처럼 간접적으로 접근해야 하는 불편이 있다.
 * "JAXB"는 XML의 정보를 그대로 담고 있는 오브젝트 트리 구조로 만들어주기 때문에 XML 정보를 오브젝트처럼 다룰 수 있어 편리하다. 
 * "JAXB"는 XML 문서의 구조를 정의한 스키마를 이용해서 매핑할 오브젝트의 클래스까지 자동으로 만들어주는 컴파일러도 제공해준다.
 ( 스키마 컴파일러를 통해 자동생성된 오브젝트에는 매핑정보가 애노테이션으로 담겨 있다. <br> JAXB API는 애노테이션에 담긴 정보를 이용해서 XML 과 매핑된 오브젝트 트리 사이의 자동변환 작업을 수행해 준다. )  
 
 
 <br>
 
 #### SQL 맵을 위한 스키마 작성과 컴파일 
 
 : SQL 정보는 키와 SQL의 목록으로 구성된 맵 구조로 만들어두면 편리하다. 
 
 ##### SQL 맵 XML 문서
 
 ```JAVA
 <sqlmap>
        <sql key="userAdd"> insert into users(...) ...</sql>
        <sql key="userGet"> select * from users ... </sql>

 </sqlmap> 
 ```
 
 ###### SQL 맵 문서에 대한 스키마
 
 ```JAVA
 <? xml version="1.0" encoding="UTF-8"?>
 <schema xmlns="http://www.w3.org/2001/XMLSchema"
        targetNamespace="http://www.epril.com/sqlmap"
        xmlns:tns="http://www,epril.com/sqlmap" elementFormDefault="qualified">
        
        <element name="sqlmap">
              <complexType>
                    <sequence>      
                        <element name="sql" maxOccurs="unbounded" type="tns:sqlType" />
                    </sequence>
              </complexType>
        </element>
        <complexType name="sqlType">
               <simpleContent>
                     <extension base="string">
                            <attribute name="key" use="required" type="string" />
                     </extension>
               </simpleContent>
        </complexType>
</schema>
```


###### SqlmapType 클래스

```java
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "sqlmapType", propOrder = { "sql" })
@XmlRootElement(name = "sqlmap")
public class SqlMap {
    @XmlElement(required = true)
    protected List<SqlType> sql;
    
    public List<SqlType> getSql(){
        if(sql == null){
            sql = new ArrayList<SqlType>();
        }
        return this.sql;
    }
}
```

```java
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "sqlType", propOrder = {"value"} )
public class SqlType {    // <sql> 태그 한 개당 SqlType 오브젝트가 하나씩 만들어진다. 

    @XmlValue
    protected String value;  // SQL 값을 저장할 스트링 타입의 필드
    
    @XmlAttribute(required = true)
    protected String key; 
    
    public String getValue(){
        return value; 
    }
    
    public void setValue(String value){
        this.value = value;
    }
    
    public String getKey(){
        return key; 
    }
    
    public void setKey(String value){
        this.key = value; 
    }


}
```

### 언마샬링

: 생성된 매핑 클래스를 적용하기 전에 먼저 JAXB API 의 사용법을 익힐 수 있도록 간단한 학습 테스트를 만들어보자. 

##### 테스트용 SQL 맵 XML 문서

```java
<? xml version="1.0" encoding="UTF-8"?>
<sqlmap xmlns="http://www.epril.com/sqlmap"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.epril.com/sqlmap ../../../../sqlmap.xsd ">
            <sql key="add">insert</sql>
            <sql key="get">select</sql>
            <sql key="delete">delete></sql>
</sqlmap>
```

* sqlmap.xml이 JAXB 언마샬링을 통해 매핑 오브젝트로 변환되는지 확인해보자.

##### JAXB 학습 테스트

```java
public class JaxbTest {

    @Test
    public void readSqlmap() throws JAXBException, IOException {
        String contextPath = Sqlmap.class.getPackage().getName(); 
        JAXBContext context = JAXBContext.newInstance(contextPath);  // 바인딩용 클래스들 위치를 가지고 JAXB 컨텍스트를 만든다.
        
        
        Unmarshaller unmashaller = context.createUnmarshaller();  // 언마샬러 생성
        
        Sqlmap sqlmap = (Sqlmap) unmarshaller.unmarshal(          // 언마샬을 하면 매핑된 오브젝트 트리의 루트인 Sqlmap을 돌려준다.
                getClass().getResourceAsStream("sqlmap.xml")); 
        
        List<SqlType> sqlList = sqlmap.getSql(); 
        
        assertThat(sqlList.size(), is(3)); 
        assertThat(sqlList.get(0).getKey(), is("add"));
        assertThat(sqlList.get(0).getValue(), is("insert"));
        assertThat(sqlList.get(1).getKey(), is("get"));
        assertThat(sqlList.get(1).getValue(), is("select"));
        assertThat(sqlList.get(2).getKey(), is("delete"));
        assertThat(sqlList.get(3).getValue(), is("delete"));        // List에 담겨 있는 sql 오브젝트를 가져와 XML 문서와 같은 정보를 갖고 있는지 확인한다.
    }
}
```

<br>

---

### XML 파일을 이용하는 SQL 서비스

> SQL 맵 XML 파일 
> 빈의 초기화 작업

#### SQL 맵 XML 파일

```JAVA
<?xml version="1.0" encoding="UTF-8?>
<sqlmap xmlns="http://www.epril.com/sqlmap"
            xmlns="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.epril.com/sqlmap
                            http://www.epril.com/sqlmapsqlmap.xsd">
    <sql key="userAdd">insert into users(id, name, password, email, level, login, recommend) values(?,?,?,?,?,?,?) </sql>
    <sql key="userGet">select * from users where id = ?</sql>
    <sql key="userGetAll">select * from users order by id</sql>
    <sql key="userDeleteAll">delete from users</sql>
    <sql key="userGetCount'>select count(*) from users</sql>
    <sql key="userUpdate">update users set name = ?, password = ?, email = ?, level = ?, login =?, recommend = ? where id = ? </sql>

</sqlmap>
```

#### XML SQL 서비스 

: 언제 JAXB를 사용해 XML 문서를 가져올지 생각해봐야 한다. 

* DAO 가 SQL 을 요청할 때마다 매번 XML 파일을 다시 읽어서 SQL을 찾는 건 너무 비효율적인 방법이다. <br>
* 특별한 이유가 없는 한 XML 파일은 한 번만 읽도록 해야 한다. 

##### 생성자 초기화 방법을 사용하는 XmlSqlService  클래스

```java
public class XmlSqlService implements SqlService {
    private Map<String, String> sqlMap = new HashMap<String, String>();
    
    public XmlSqlService(){
    
        String contextPath = Sqlmap.class.getPackage().getName(); 
        try{
            JAXBContext context = JAXBContext.newInstance(contextPath);
            Unmarshaller unmarshaller = context.createUnmarshaller();
            InputStream is = UserDao.class.getResourceAsStream("sqlmap.xml");
            Sqlmap sqlmap = (Sqlmap) unmarshaller.unmarshal(is);
            
            
            for(SqlType sql : sqlmap.getSql()){
                sqlMap.put(sql.getKey(), sql.getValue());
                    
            }
        
        }catch(JAXBException e)}
            throw new RuntimeException(e); 
        }
    }
    public String getSql(String key) throws SqlRetrievalFailureException {
        String sql = sqlMap.get(key);
        if(sql == null)
            throw new SqlRetrievalFailureException(key + "를 이용해서 SQL을 찾을 수 없습니다.");
        else 
            return sql; 
    }
}
```

##### sqlService 설정 변경

```
<bean id="sqlService" class="springbook.user.sqlservice.XmlSqlService">
</bean>
```
