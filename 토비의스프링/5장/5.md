# 서비스 추상화 

지금까지 만든 DAO에 트랜잭션을 적용해보면서 스프링이 어떻게 성격이 비슷한 여러 종류의 기술을 추상황하고 이를 일관된 방법으로 사용할 수 있도록 지원하는지 살펴본다. 

---

### 사용자 레벨 관리 기능 추가.
예제1) 
- 사용자 레벨은 BASIC, SILVER, GOLD 세 가지 중 하나다. 
- 사용자가 처음 가입하면 BASIC 레벨이 되며, 이후 활동에 따라서 한 단계식 업그레이드 될 수 있다.
- 가입 후 50회 이상 로그인을 하면 BASIC에서 SILVER 레벨이 된다.  
- SILVER 레벨이면서 30번 이상 추천을 받으면 GOLD 레벨이 된다.
- 사용자 레벨의 변경 작업은 일정한 주기를 가지고 일괄적으로 진행된다. 변경 작업 전에는 조건을 충족하더라도 레벨의 변경이 일어나지 않는다.


+ 방법1) 상수 정해놓고 int 타입으로 레벨 사용.  
```
  class User { 
    private static final int BASIC = 1; 
    private static final int SILVER = 2; 
    private static final int GOLD =3; 
    
    int level;
    
    public void setLevel(int level){
      this.level = level; 
    }
  
  }
 ```
 사용방법↓
```
  if(user1.getLevel() == User.BASIC){
    user1.setLevel(User.SILVER);
  }
```

##### 발생할 수 있는 문제 
level의 타입이 int이기 때문에 다음처럼 다른 종류의 정보를 넣는 실수를 해도 컴파일러가 체크해주지 못한다.
```
  user1.setLevel(other.getSum());
```
아래 같이 범위를 벗어나는 값을 넣을 위험도 있다.
``` 
  user1.setLevel(1000); 
```

방법2) enum 이용 ( 자바 5 이상 ) 
```
  public enum Level { 
    BASIC(1), SILVER(2), GOLD(3);   // 3개의 이늄 오브젝트 정의
  
    private final int value; 
    
    Level(int value) {  // DB에 저장할 값을 넣어줄 생성자를 만든다.
       this.vallue = value; 
    }
    public int intValue(){  // 값을 가져오는 메소드 
      return value; 
    }
    
    public static Level valueOf(int value){  // 값으로부터 Level 타입 오브젝트를 가져오도록 만든 스태틱 메소드 
      switch (value) {
        case 1 : return BASIC; 
        case 2 : return SILVER; 
        case 3 : return GOLD; 
        default : throw new AssertionError("Unkown vaue : " + value); 
      }
    }
  }

```
장점 
-> Level 이늄은 내부에서 DB에 저장할 int 타입의 값을 갖고 있지만, 겉으로는 Level 타입의 오브젝트이기 때문에 안전하게 사용할 수 있다.
  (user1.setLevel(100) 과 같은 코드를 거를 수 있다.) 
  

<br><br>



### User 필드 추가.  ( 사용자 관리 레벨 로직에서 언급된  + 로그인 횟수와 추천수도 추가)
```
public class User { 
  Level level; 
  int login;
  int recommand; 
  
  
  public User(String id, String name, String password, Level level, int login, int recommand){
    this.id = id; 
    this.name = name; 
    this.password = password; 
    this.level = level; 
    this.login = login; 
    this.recommand = recommand; 
  
  }
  
  
  
  public Level getLevel(){
    return level; 
  }
  
  public void setLevel(Level level){
    this.value = level;
  }
  
  ...
  // login, recommend getter/setter 생략
  
```

```
public clas UserDaoTest { 
   ...
   @Before{
   public void setUp(){
    this.user1 = new User("chungjin", "이충진", "libra10042", Level.BASIC, 1, 0);
    this.user2 = new User("chungjin2", "이충진", "libra100422", Level.SILVER, 55, 10);
    this.user3 = new User("chungjin3", "이충진", "libra1004222", Level.GOLD, 100, 40);
  }
}

```
<br><br>

#### User 필드 값 검증 메소드
```
private void checkSameUser(User user1, User user2){
  assertThat(user1.getId(), id(userr2.getId()));
  assertThat(user1.getName(), id(user2.getName()));
  assertThat(user1.getPassword(), id(user2.getPassword()));
  assertThat(user1.getLevel(), id(user2.getLevel()));
  assertThat(user1.getLogin(), is(user2.getLogin()));
  assertThat(user1.getRecommand(), is(user2.getRecommand())); 
}
```
##### checkSameUser() 메소드를 사용하도록 만든 addAndGet() 메소드 
```
@Test public void addAndGet(){
  ...
  User userget1 = dao.get(user1.getId());
  checkSameUser(userget1, user1);
  
  User userget2 = dao.get(user.getId());
  checkSameUser(userget2, user2); 
}
```

